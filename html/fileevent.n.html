<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">
<html><head>
<title>n man page</title>
<meta name="generator" content="roffit">
<STYLE type="text/css">
pre {
  overflow: auto;
  margin: 0;
}

P.level0, pre.level0 {
 padding-left: 2em;
}

P.level1, pre.level1 {
 padding-left: 4em;
}

P.level2, pre.level2 {
 padding-left: 6em;
}

span.emphasis {
 font-style: italic;
}

span.bold {
 font-weight: bold;
}

span.manpage {
 font-weight: bold;
}

h2.nroffsh {
 background-color: #e0e0e0;
}

span.nroffip {
 font-weight: bold;
 font-size: 120%;
 font-family: monospace;
}

p.roffit {
 text-align: center;
 font-size: 80%;
}
</STYLE>
</head><body>
See the man.macros man page.

<p class="level0">
<p class="level0"><a name="NAME"></a><h2 class="nroffsh">NAME</h2>
<p class="level0">fileevent - Execute a script when a file becomes readable or writable <a name="SYNOPSIS"></a><h2 class="nroffsh">SYNOPSIS</h2>
<p class="level0"><span class="bold">fileevent <span class="emphasis">fileId <span Class="bold">readable </span>?<span Class="emphasis">script</span>? <br><span class="bold">fileevent <span class="emphasis">fileId <span Class="bold">writable </span>?<span Class="emphasis">script</span>? 
<p class="level0">
<p class="level0"><a name="DESCRIPTION"></a><h2 class="nroffsh">DESCRIPTION</h2>
<p class="level0">
<p class="level0">This command is used to create <span Class="emphasis">file event handlers</span>. A file event handler is a binding between a file and a script, such that the script is evaluated whenever the file becomes readable or writable. File event handlers are most commonly used to allow data to be received from a child process on an event-driven basis, so that the receiver can continue to interact with the user while waiting for the data to arrive. If an application invokes <span Class="bold">gets</span> or <span Class="bold">read</span> when there is no input data available, the process will block;  until the input data arrives, it will not be able to service other events, so it will appear to the user to ``freeze up&#39;&#39;. With <span Class="bold">fileevent</span>, the process can tell when data is present and only invoke <span Class="bold">gets</span> or <span Class="bold">read</span> when they won&#39;t block. 
<p class="level0">The <span Class="emphasis">fileId</span> argument to <span Class="bold">fileevent</span> refers to an open file; it must be <span Class="bold">stdin</span>, <span Class="bold">stdout</span>, <span Class="bold">stderr</span>, or the return value from some previous <span Class="bold">open</span> command. If the <span Class="emphasis">script</span> argument is specified, then <span Class="bold">fileevent</span> creates a new event handler:  <span Class="emphasis">script</span> will be evaluated whenever the file becomes readable or writable (depending on the second argument to <span Class="bold">fileevent</span>). In this case <span Class="bold">fileevent</span> returns an empty string. The <span Class="bold">readable</span> and <span Class="bold">writable</span> event handlers for a file are independent, and may be created and deleted separately. However, there may be at most one <span Class="bold">readable</span> and one <span Class="bold">writable</span> handler for a file at a given time. If <span Class="bold">fileevent</span> is called when the specified handler already exists, the new script replaces the old one. 
<p class="level0">If the <span Class="emphasis">script</span> argument is not specified, <span Class="bold">fileevent</span> returns the current script for <span Class="emphasis">fileId</span>, or an empty string if there is none. If the <span Class="emphasis">script</span> argument is specified as an empty string then the event handler is deleted, so that no script will be invoked. A file event handler is also deleted automatically whenever its file is closed or its interpreter is deleted. 
<p class="level0">A file is considered to be readable whenever the <span Class="bold">gets</span> and <span Class="bold">read</span> commands can return without blocking. A file is also considered to be readable if an end-of-file or error condition is present. It is important for <span Class="emphasis">script</span> to check for these conditions and handle them appropriately;  for example, if there is no special check for end-of-file, an infinite loop may occur where <span Class="emphasis">script</span> reads no data, returns, and is immediately invoked again. 
<p class="level0">When using <span Class="bold">fileevent</span> for event-driven I/O, it&#39;s important to read the file in the same units that are written from the other end. For example, suppose that you are using <span Class="bold">fileevent</span> to read data generated by a child process. If the child process is writing whole lines, then you should use <span Class="bold">gets</span> to read those lines. If the child generates one line at a time then you shouldn&#39;t make more than a single call to <span Class="bold">gets</span> in <span Class="emphasis">script</span>: the first call will consume all the available data, so the second call may block. You can also use <span Class="bold">read</span> to read the child&#39;s data, but only if you know how many bytes the child is writing at a time:  if you try to read more bytes than the child has written, the <span Class="bold">read</span> call will block. 
<p class="level0">A file is considered to be writable if at least one byte of data can be written to the file without blocking, or if an error condition is present. Write handlers are probably not very useful without additional command support. The <span Class="bold">puts</span> command is dangerous since it write more than one byte at a time and may thus block. What is really needed is a new non-blocking form of write that saves any data that couldn&#39;t be written to the file. 
<p class="level0">The script for a file event is executed at global level (outside the context of any Tcl procedure). If an error occurs while executing the script then the <span Class="bold">tkerror</span> mechanism is used to report the error. In addition, the file event handler is deleted if it ever returns an error;  this is done in order to prevent infinite loops due to buggy handlers. 
<p class="level0"><a name="CREDITS"></a><h2 class="nroffsh">CREDITS</h2>
<p class="level0">
<p class="level0"><span Class="bold">fileevent</span> is based on the <span Class="bold">addinput</span> command created by Mark Diekhans. 
<p class="level0"><a name="SEE"></a><h2 class="nroffsh">SEE ALSO</h2>
<p class="level0">tkerror 
<p class="level0"><a name="KEYWORDS"></a><h2 class="nroffsh">KEYWORDS</h2>
<p class="level0">asynchronous I/O, event handler, file, readable, script, writable <p class="roffit">
 This HTML page was made with <a href="http://daniel.haxx.se/projects/roffit/">roffit</a>.
</body></html>
